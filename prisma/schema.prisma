generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  MANAGER
  CLUB_OWNER
  ADMIN
}

enum InviteStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

model User {
  id             String              @id @default(cuid())
  email          String              @unique
  name           String
  emailVerified  Boolean
  isPrivate      Boolean             @default(false)
  eventsSignedUp EventRegistration[]
  invitesSent    EventInvite[]
  clubMembership ClubMembership[]
  clubInvitesReceived ClubInvite[]

  image   String?
  session Session[]
  account Account[]

  // Other, optional user information
  bio      String?
  location String?
  website  String?
  phone    String?
  callsign String?
  gear     Json[] // { name: string, energy: string, fps: string }

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  passkeys  Passkey[]
}

model Club {
  id String @id @default(cuid())

  name        String
  location    String?
  description String?
  dateFounded DateTime?

  isAllied  Boolean @default(false)
  isPrivate Boolean @default(false)

  logo String?

  contactPhone String?
  contactEmail String?

  events         Event[]
  members        ClubMembership[]
  invitesSent    ClubInvite[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}


model ClubMembership {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
  club   Club   @relation(fields: [clubId], references: [id], onDelete: Cascade)
  clubId String
  role   Role   @default(USER)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, clubId])
}

model ClubInvite {
  id          String       @id @default(cuid())
  email       String       // Email of the invited user
  club        Club         @relation(fields: [clubId], references: [id], onDelete: Cascade)
  clubId      String
  user        User?        @relation(fields: [userId], references: [id]) // Optional: If the email matches an existing user
  userId      String?
  status      InviteStatus @default(PENDING)
  inviteCode  String       @unique
  expiresAt   DateTime
  
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([email])
  @@index([status])
  @@index([inviteCode])
}

// Rest of your existing models remain the same...
model Event {
  id          String @id @default(cuid())
  name        String
  description String
  club        Club   @relation(fields: [clubId], references: [id], onDelete: Cascade)
  clubId      String

  coverImage String?

  dateStart DateTime
  dateEnd   DateTime?

  dateRegistrationsClose DateTime?
  dateRegistrationsOpen  DateTime?

  isPrivate        Boolean @default(false) // Private events are club-only events
  allowFreelancers Boolean @default(false) // Allow people not in a club to register

  location       String
  googleMapsLink String?

  costPerPerson Float @default(0)

  // Event-specific features
  hasBreakfast Boolean @default(false)
  hasLunch     Boolean @default(false)
  hasDinner    Boolean @default(false)
  hasSnacks    Boolean @default(false)
  hasDrinks    Boolean @default(false)
  hasPrizes    Boolean @default(false)

  // Event-specific rules
  rules Json[] // { name: string, description: string }

  // Event-specific gear requirements
  gearRequirements Json[] // { name: string, description: string }
  mapData          Json?

  registrations EventRegistration[]
  invites       EventInvite[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model EventRegistration {
  id       String  @id @default(cuid())
  event    Event   @relation(fields: [eventId], references: [id])
  eventId  String
  user     User?   @relation(fields: [userId], references: [id])
  userId   String? // Can be null for non-account users
  invite   EventInvite? @relation(fields: [inviteId], references: [id])
  inviteId String? // Event can be registered by invite link

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Invite Model (Manual Event Registration)
model EventInvite {
  id                String              @id @default(cuid())
  event             Event               @relation(fields: [eventId], references: [id])
  eventId           String
  email             String              // Email of the person receiving the invite
  secureLink        String              @unique // Generated unique link for registration
  inviter           User                @relation(fields: [inviterId], references: [id])
  inviterId         String
  eventRegistration EventRegistration[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Auth stuff below

model Session {
  id        String   @id
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Account {
  id           String    @id
  accountId    String
  providerId   String
  userId       String
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken  String?
  refreshToken String?
  idToken      String?
  expiresAt    DateTime?
  password     String?
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
}

model Passkey {
  id             String    @id
  name           String?
  publicKey      String
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  webauthnUserID String
  counter        Int
  deviceType     String
  backedUp       Boolean
  transports     String?
  createdAt      DateTime?
}
