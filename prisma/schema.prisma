generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  MANAGER
  CLUB_OWNER
}

enum InviteStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

model User {
  id            String  @id @default(cuid())
  email         String  @unique
  name          String
  emailVerified Boolean
  isPrivate     Boolean @default(false)

  clubMembership      ClubMembership[]
  clubInvitesReceived ClubInvite[]

  image   String?
  session Session[]
  account Account[]

  slug String? @unique

  // Other, optional user information
  bio      String?
  location String?
  website  String?
  phone    String?
  callsign String?
  gear     Json[] // { name: string, energy: string, fps: string }

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  passkeys  Passkey[]

  eventRegistration         EventRegistration[]
  createdEventRegistrations EventRegistration[] @relation("EventRegistrationCreatedBy")
  role                      String? // BetterAuth role
  banned                    Boolean?
  banReason                 String?
  banExpires                DateTime?
}

model Club {
  id String @id @default(cuid())

  name        String
  location    String?
  description String?
  dateFounded DateTime?

  slug String? @unique

  isAllied  Boolean @default(false)
  isPrivate Boolean @default(false)

  logo String?

  contactPhone String?
  contactEmail String?

  events      Event[]
  rules       ClubRule[]
  members     ClubMembership[]
  invitesSent ClubInvite[]

  banned     Boolean?
  banReason  String?
  banExpires DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ClubRule {
  id          String   @id @default(cuid())
  name        String
  description String?
  content     Json // This will store the editor's JSON content
  club        Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)
  clubId      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  Event       Event?   @relation(fields: [eventId], references: [id])
  eventId     String?
}

model ClubMembership {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
  club   Club   @relation(fields: [clubId], references: [id], onDelete: Cascade)
  clubId String
  role   Role   @default(USER)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@unique([userId, clubId])
}

model ClubInvite {
  id         String       @id @default(cuid())
  email      String // Email of the invited user
  club       Club         @relation(fields: [clubId], references: [id], onDelete: Cascade)
  clubId     String
  user       User?        @relation(fields: [userId], references: [id]) // Optional: If the email matches an existing user
  userId     String?
  status     InviteStatus @default(PENDING)
  inviteCode String       @unique
  expiresAt  DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@index([email])
  @@index([status])
  @@index([inviteCode])
}

model Event {
  id          String @id @default(cuid())
  name        String
  description String
  club        Club   @relation(fields: [clubId], references: [id], onDelete: Cascade)
  clubId      String

  coverImage String?

  dateStart DateTime
  dateEnd   DateTime

  slug String? @unique

  dateRegistrationsClose DateTime
  dateRegistrationsOpen  DateTime

  isPrivate        Boolean @default(false) // Private events are club-only events
  allowFreelancers Boolean @default(false) // Allow people not in a club to register

  location       String
  googleMapsLink String?

  costPerPerson Float @default(0)

  // Event-specific features
  hasBreakfast Boolean @default(false)
  hasLunch     Boolean @default(false)
  hasDinner    Boolean @default(false)
  hasSnacks    Boolean @default(false)
  hasDrinks    Boolean @default(false)
  hasPrizes    Boolean @default(false)

  // Event-specific rules
  rules ClubRule[]

  // Event-specific gear requirements
  gearRequirements Json[] // { name: string, description: string }
  mapData          Json?

  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  eventRegistration EventRegistration[]
  eventInvite       EventInvite[]
}

model EventRegistration {
  id      String @id @default(cuid())
  event   Event  @relation(fields: [eventId], references: [id])
  eventId String

  createdById String
  createdBy   User   @relation(fields: [createdById], references: [id], name: "EventRegistrationCreatedBy")

  invitedUsers         User[]
  invitedUsersNotOnApp EventInvite[]

  type          String  @default("solo") // solo, team
  paymentMethod String  @default("cash") // cash, bank
  attended      Boolean @default(false) // Add this field

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())
}

model EventInvite {
  id        String   @id @default(cuid())
  event     Event    @relation(fields: [eventId], references: [id])
  eventId   String
  name      String
  email     String
  token     String   @unique
  expiresAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  eventRegistration   EventRegistration? @relation(fields: [eventRegistrationId], references: [id])
  eventRegistrationId String?
}

// Auth stuff below

model Session {
  id        String   @id
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String
  createdAt DateTime
  updatedAt DateTime

  impersonatedBy String?

  @@unique([token])
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  expiresAt             DateTime?
  password              String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  createdAt             DateTime
  updatedAt             DateTime
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?
}

model Passkey {
  id             String    @id
  name           String?
  publicKey      String
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  webauthnUserID String
  counter        Int
  deviceType     String
  backedUp       Boolean
  transports     String?
  createdAt      DateTime?
}
